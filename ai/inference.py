"""
AI inference engine for generating trading signals and recommendations.

This module provides the main AI engine that combines multiple ML models
(LSTM, Random Forest) to generate trading signals, recommendations, and
explanations for stock analysis.
"""

import numpy as np
import pandas as pd
from typing import Optional, Dict, Any, List, Tuple
from dataclasses import dataclass, field
from datetime import datetime
import os
import logging

from ai.models.lstm_model import LSTMPricePredictor
from ai.models.rf_model import RandomForestTrader
from utils.indicators import sma, ema, rsi, macd, bollinger_bands, atr
from utils.asset_analysis import (
    calculate_asset_specific_indicators,
    get_asset_class_risk_metrics
)
from services.market_data_service import AssetClass

logger = logging.getLogger(__name__)


@dataclass
class TradingSignal:
    """
    Trading signal generated by AI models.
    
    Represents a complete trading recommendation with confidence scores,
    reasoning, and model predictions.
    """
    symbol: str
    action: str  # 'buy', 'sell', 'hold'
    confidence: float  # 0.0 to 1.0
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    reasoning: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)
    model_predictions: Dict[str, float] = field(default_factory=dict)
    asset_class: AssetClass = AssetClass.STOCK


@dataclass
class Recommendation:
    """
    Detailed trading recommendation with explanation.
    
    Provides a comprehensive recommendation including action, confidence,
    price targets, and detailed reasoning for the decision.
    """
    symbol: str
    action: str  # 'buy', 'sell', 'hold'
    confidence: float  # 0.0 to 1.0
    current_price: float
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    expected_return: Optional[float] = None
    risk_level: str = 'medium'  # 'low', 'medium', 'high'
    reasoning: List[str] = field(default_factory=list)
    technical_factors: Dict[str, Any] = field(default_factory=dict)
    model_scores: Dict[str, float] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)
    asset_class: AssetClass = AssetClass.STOCK


@dataclass
class RankedStock:
    """
    Stock ranked by trading opportunity strength.
    
    Used for comparing multiple stocks and identifying the best opportunities.
    """
    symbol: str
    score: float  # Overall opportunity score (0-100)
    action: str  # 'buy', 'sell', 'hold'
    confidence: float
    expected_return: Optional[float] = None
    risk_level: str = 'medium'
    key_factors: List[str] = field(default_factory=list)
    asset_class: AssetClass = AssetClass.STOCK


class AIEngine:
    """
    AI inference engine for trading signal generation.
    
    This engine combines multiple ML models (LSTM for price prediction,
    Random Forest for classification) to generate comprehensive trading
    signals and recommendations with explanations.
    """
    
    def __init__(
        self,
        model_dir: str = 'data/models',
        lstm_model_name: str = 'lstm_model',
        rf_model_name: str = 'rf_model',
        ensemble_weights: Optional[Dict[str, float]] = None
    ):
        """
        Initialize AI engine.
        
        Args:
            model_dir: Directory containing trained models
            lstm_model_name: Name of LSTM model file (without extension)
            rf_model_name: Name of Random Forest model file (without extension)
            ensemble_weights: Weights for ensemble prediction
                            {'lstm': 0.4, 'rf': 0.6} by default
        """
        self.model_dir = model_dir
        self.lstm_model_name = lstm_model_name
        self.rf_model_name = rf_model_name
        
        # Default ensemble weights
        self.ensemble_weights = ensemble_weights or {
            'lstm': 0.4,
            'rf': 0.6
        }
        
        # Models (loaded lazily)
        self.lstm_model: Optional[LSTMPricePredictor] = None
        self.rf_model: Optional[RandomForestTrader] = None
        
        # Model status
        self.models_loaded = False
        self.available_models = []
        
        # Configuration
        self.min_confidence_threshold = 0.6
        self.risk_free_rate = 0.04  # 4% annual risk-free rate
        
        logger.info(f"Initialized AI engine with model directory: {model_dir}")
    
    def load_models(self, force_reload: bool = False) -> Dict[str, bool]:
        """
        Load trained models from disk.
        
        Args:
            force_reload: Force reload even if models are already loaded
            
        Returns:
            Dictionary indicating which models were successfully loaded
        """
        if self.models_loaded and not force_reload:
            logger.info("Models already loaded")
            return {
                'lstm': self.lstm_model is not None,
                'rf': self.rf_model is not None
            }
        
        results = {}
        self.available_models = []
        
        # Load LSTM model
        lstm_path = os.path.join(self.model_dir, self.lstm_model_name)
        try:
            if os.path.exists(f"{lstm_path}.h5"):
                self.lstm_model = LSTMPricePredictor()
                self.lstm_model.load(lstm_path)
                self.available_models.append('lstm')
                results['lstm'] = True
                logger.info(f"Loaded LSTM model from {lstm_path}")
            else:
                logger.warning(f"LSTM model not found at {lstm_path}")
                results['lstm'] = False
        except Exception as e:
            logger.error(f"Failed to load LSTM model: {e}")
            results['lstm'] = False
            self.lstm_model = None
        
        # Load Random Forest model
        rf_path = os.path.join(self.model_dir, self.rf_model_name)
        try:
            if os.path.exists(f"{rf_path}.pkl"):
                self.rf_model = RandomForestTrader()
                self.rf_model.load(rf_path)
                self.available_models.append('rf')
                results['rf'] = True
                logger.info(f"Loaded Random Forest model from {rf_path}")
            else:
                logger.warning(f"Random Forest model not found at {rf_path}")
                results['rf'] = False
        except Exception as e:
            logger.error(f"Failed to load Random Forest model: {e}")
            results['rf'] = False
            self.rf_model = None
        
        self.models_loaded = any(results.values())
        
        if not self.models_loaded:
            logger.warning("No models were successfully loaded")
        else:
            logger.info(f"Successfully loaded models: {self.available_models}")
        
        return results
    
    def _calculate_technical_indicators(self, data: pd.DataFrame) -> Dict[str, Any]:
        """
        Calculate technical indicators from price data.
        
        Args:
            data: DataFrame with OHLCV data
            
        Returns:
            Dictionary of technical indicators
        """
        close = data['close'].values
        high = data['high'].values
        low = data['low'].values
        
        indicators = {}
        
        try:
            # Moving averages
            indicators['sma_20'] = float(sma(close, 20)[-1])
            indicators['sma_50'] = float(sma(close, 50)[-1])
            indicators['ema_12'] = float(ema(close, 12)[-1])
            indicators['ema_26'] = float(ema(close, 26)[-1])
            
            # RSI
            rsi_values = rsi(close, 14)
            indicators['rsi'] = float(rsi_values[-1])
            
            # MACD
            macd_line, signal_line, histogram = macd(close)
            indicators['macd'] = float(macd_line[-1])
            indicators['macd_signal'] = float(signal_line[-1])
            indicators['macd_histogram'] = float(histogram[-1])
            
            # Bollinger Bands
            upper, middle, lower = bollinger_bands(close, 20, 2.0)
            indicators['bb_upper'] = float(upper[-1])
            indicators['bb_middle'] = float(middle[-1])
            indicators['bb_lower'] = float(lower[-1])
            indicators['bb_width'] = float((upper[-1] - lower[-1]) / middle[-1])
            
            # ATR
            atr_values = atr(high, low, close, 14)
            indicators['atr'] = float(atr_values[-1])
            
            # Price position
            current_price = float(close[-1])
            indicators['price_vs_sma20'] = (current_price - indicators['sma_20']) / indicators['sma_20']
            indicators['price_vs_sma50'] = (current_price - indicators['sma_50']) / indicators['sma_50']
            
        except Exception as e:
            logger.error(f"Error calculating technical indicators: {e}")
        
        return indicators
    
    def _prepare_features(self, data: pd.DataFrame) -> np.ndarray:
        """
        Prepare feature array for model input.
        
        Args:
            data: DataFrame with OHLCV data and indicators
            
        Returns:
            Feature array for model input
        """
        # Calculate returns
        returns = data['close'].pct_change().fillna(0)
        
        # Calculate volatility
        volatility = returns.rolling(window=20).std().fillna(0)
        
        # Prepare feature matrix
        features = np.column_stack([
            data['close'].values,
            data['volume'].values,
            returns.values,
            volatility.values,
            data['high'].values - data['low'].values  # Daily range
        ])
        
        return features
    
    def analyze_stock(
        self, 
        symbol: str, 
        data: pd.DataFrame,
        asset_class: AssetClass = AssetClass.STOCK
    ) -> TradingSignal:
        """
        Generate trading signal for a stock.
        
        Analyzes the stock using available ML models and technical indicators
        to generate a comprehensive trading signal.
        
        Args:
            symbol: Stock symbol
            data: DataFrame with OHLCV data (must have columns: open, high, low, close, volume)
            asset_class: Asset class (STOCK, CRYPTO, or FOREX)
            
        Returns:
            TradingSignal with action, confidence, and reasoning
            
        Raises:
            ValueError: If data is invalid or models not loaded
        """
        if not self.models_loaded:
            self.load_models()
        
        if not self.models_loaded:
            raise ValueError("No models available for analysis")
        
        # Validate data
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        if not all(col in data.columns for col in required_columns):
            raise ValueError(f"Data must contain columns: {required_columns}")
        
        if len(data) < 60:
            raise ValueError("Need at least 60 data points for analysis")
        
        logger.info(f"Analyzing {symbol} ({asset_class.value}) with {len(data)} data points")
        
        # Add asset-specific indicators
        data_with_indicators = calculate_asset_specific_indicators(data, asset_class)
        
        # Calculate technical indicators
        indicators = self._calculate_technical_indicators(data_with_indicators)
        current_price = float(data['close'].iloc[-1])
        
        # Prepare features
        features = self._prepare_features(data)
        
        # Get predictions from available models
        predictions = {}
        model_scores = {}
        
        # LSTM prediction (price forecast)
        if self.lstm_model is not None:
            try:
                lstm_pred = self.lstm_model.predict_next(features, steps=1)[0]
                predictions['lstm'] = float(lstm_pred)
                
                # Convert to action based on price change
                price_change_pct = (lstm_pred - current_price) / current_price
                if price_change_pct > 0.02:  # >2% increase
                    model_scores['lstm'] = 1.0  # Buy
                elif price_change_pct < -0.02:  # >2% decrease
                    model_scores['lstm'] = -1.0  # Sell
                else:
                    model_scores['lstm'] = 0.0  # Hold
                
                logger.debug(f"LSTM prediction: ${lstm_pred:.2f} ({price_change_pct:.2%})")
            except Exception as e:
                logger.error(f"LSTM prediction failed: {e}")
        
        # Random Forest prediction (classification)
        if self.rf_model is not None:
            try:
                # Use last row of features for RF
                rf_features = features[-1:, :]
                rf_result = self.rf_model.predict_with_confidence(rf_features)[0]
                
                predictions['rf'] = rf_result['prediction']
                predictions['rf_confidence'] = rf_result['confidence']
                predictions['rf_probabilities'] = rf_result['probabilities']
                
                # Convert to score
                action_map = {'buy': 1.0, 'hold': 0.0, 'sell': -1.0}
                model_scores['rf'] = action_map.get(rf_result['prediction'], 0.0)
                
                logger.debug(f"RF prediction: {rf_result['prediction']} (confidence: {rf_result['confidence']:.2f})")
            except Exception as e:
                logger.error(f"Random Forest prediction failed: {e}")
        
        # Ensemble prediction
        if model_scores:
            # Weighted average of model scores
            ensemble_score = sum(
                model_scores[model] * self.ensemble_weights.get(model, 0.5)
                for model in model_scores
            ) / sum(self.ensemble_weights.get(model, 0.5) for model in model_scores)
            
            # Determine action
            if ensemble_score > 0.3:
                action = 'buy'
                confidence = min(abs(ensemble_score), 1.0)
            elif ensemble_score < -0.3:
                action = 'sell'
                confidence = min(abs(ensemble_score), 1.0)
            else:
                action = 'hold'
                confidence = 1.0 - abs(ensemble_score)
        else:
            # Fallback to technical indicators
            action = 'hold'
            confidence = 0.5
            ensemble_score = 0.0
        
        # Calculate target price and stop loss
        target_price = None
        stop_loss = None
        
        if action == 'buy':
            # Target: 5% above current price or LSTM prediction
            if 'lstm' in predictions:
                target_price = max(predictions['lstm'], current_price * 1.05)
            else:
                target_price = current_price * 1.05
            
            # Stop loss: 3% below current price
            stop_loss = current_price * 0.97
            
        elif action == 'sell':
            # Target: 5% below current price or LSTM prediction
            if 'lstm' in predictions:
                target_price = min(predictions['lstm'], current_price * 0.95)
            else:
                target_price = current_price * 0.95
            
            # Stop loss: 3% above current price
            stop_loss = current_price * 1.03
        
        # Build reasoning
        reasoning = {
            'ensemble_score': float(ensemble_score),
            'model_scores': model_scores,
            'technical_indicators': indicators,
            'current_price': current_price,
            'models_used': self.available_models
        }
        
        # Create signal
        signal = TradingSignal(
            symbol=symbol,
            action=action,
            confidence=confidence,
            target_price=target_price,
            stop_loss=stop_loss,
            reasoning=reasoning,
            timestamp=datetime.now(),
            model_predictions=predictions,
            asset_class=asset_class
        )
        
        logger.info(
            f"Generated signal for {symbol} ({asset_class.value}): {action.upper()} "
            f"(confidence: {confidence:.2f})"
        )
        
        return signal
    
    def get_recommendation(
        self, 
        symbol: str, 
        data: pd.DataFrame,
        asset_class: AssetClass = AssetClass.STOCK
    ) -> Recommendation:
        """
        Get detailed trading recommendation with explanation.
        
        Generates a comprehensive recommendation including action, confidence,
        price targets, risk assessment, and detailed reasoning.
        
        Args:
            symbol: Stock symbol
            data: DataFrame with OHLCV data
            asset_class: Asset class (STOCK, CRYPTO, or FOREX)
            
        Returns:
            Recommendation object with detailed analysis
        """
        # Generate signal
        signal = self.analyze_stock(symbol, data, asset_class)
        
        current_price = signal.reasoning['current_price']
        indicators = signal.reasoning['technical_indicators']
        
        # Calculate expected return
        expected_return = None
        if signal.target_price:
            expected_return = (signal.target_price - current_price) / current_price
        
        # Assess risk level (adjusted for asset class)
        risk_level = self._assess_risk(indicators, signal.confidence, asset_class)
        
        # Generate reasoning text
        reasoning_text = self._generate_reasoning(signal, indicators, asset_class)
        
        # Create recommendation
        recommendation = Recommendation(
            symbol=symbol,
            action=signal.action,
            confidence=signal.confidence,
            current_price=current_price,
            target_price=signal.target_price,
            stop_loss=signal.stop_loss,
            expected_return=expected_return,
            risk_level=risk_level,
            reasoning=reasoning_text,
            technical_factors=indicators,
            model_scores=signal.reasoning['model_scores'],
            timestamp=signal.timestamp,
            asset_class=asset_class
        )
        
        return recommendation
    
    def _assess_risk(
        self, 
        indicators: Dict[str, Any], 
        confidence: float,
        asset_class: AssetClass = AssetClass.STOCK
    ) -> str:
        """
        Assess risk level based on indicators and confidence.
        
        Args:
            indicators: Technical indicators
            confidence: Model confidence
            asset_class: Asset class (affects risk assessment)
            
        Returns:
            Risk level: 'low', 'medium', or 'high'
        """
        risk_score = 0
        
        # Base risk by asset class
        if asset_class == AssetClass.CRYPTO:
            risk_score += 1  # Crypto is inherently more volatile
        elif asset_class == AssetClass.FOREX:
            risk_score += 0  # Forex typically lower volatility
        
        # High volatility increases risk
        if 'atr' in indicators and 'close' in indicators:
            atr_pct = indicators['atr'] / indicators.get('close', 1)
            if asset_class == AssetClass.CRYPTO:
                # Higher threshold for crypto
                if atr_pct > 0.05:  # >5% daily range
                    risk_score += 1
            else:
                if atr_pct > 0.03:  # >3% daily range
                    risk_score += 1
        
        # Extreme RSI increases risk
        if 'rsi' in indicators:
            rsi_val = indicators['rsi']
            if rsi_val > 70 or rsi_val < 30:
                risk_score += 1
        
        # Low confidence increases risk
        if confidence < 0.7:
            risk_score += 1
        
        # Wide Bollinger Bands indicate high volatility
        if 'bb_width' in indicators and indicators['bb_width'] > 0.1:
            risk_score += 1
        
        # Determine risk level
        if risk_score >= 3:
            return 'high'
        elif risk_score >= 1:
            return 'medium'
        else:
            return 'low'
    
    def _generate_reasoning(
        self,
        signal: TradingSignal,
        indicators: Dict[str, Any],
        asset_class: AssetClass = AssetClass.STOCK
    ) -> List[str]:
        """
        Generate human-readable reasoning for the signal.
        
        Args:
            signal: Trading signal
            indicators: Technical indicators
            asset_class: Asset class
            
        Returns:
            List of reasoning statements
        """
        reasoning = []
        
        # Asset class context
        asset_name = asset_class.value.title()
        
        # Model consensus
        if len(signal.reasoning['model_scores']) > 1:
            reasoning.append(
                f"Multiple AI models agree on {signal.action.upper()} signal for {asset_name} "
                f"with {signal.confidence:.0%} confidence"
            )
        else:
            reasoning.append(
                f"AI model suggests {signal.action.upper()} for {asset_name} "
                f"with {signal.confidence:.0%} confidence"
            )
        
        # Price prediction
        if 'lstm' in signal.model_predictions:
            pred_price = signal.model_predictions['lstm']
            current_price = signal.reasoning['current_price']
            change_pct = (pred_price - current_price) / current_price
            reasoning.append(
                f"Price forecast: ${pred_price:.2f} ({change_pct:+.1%})"
            )
        
        # RSI analysis
        if 'rsi' in indicators:
            rsi_val = indicators['rsi']
            if rsi_val > 70:
                reasoning.append(f"RSI at {rsi_val:.1f} indicates overbought conditions")
            elif rsi_val < 30:
                reasoning.append(f"RSI at {rsi_val:.1f} indicates oversold conditions")
            else:
                reasoning.append(f"RSI at {rsi_val:.1f} shows neutral momentum")
        
        # Moving average analysis
        if 'price_vs_sma20' in indicators:
            pct_vs_sma = indicators['price_vs_sma20'] * 100
            if pct_vs_sma > 2:
                reasoning.append(f"Price {pct_vs_sma:.1f}% above 20-day average (bullish)")
            elif pct_vs_sma < -2:
                reasoning.append(f"Price {abs(pct_vs_sma):.1f}% below 20-day average (bearish)")
        
        # MACD analysis
        if 'macd_histogram' in indicators:
            macd_hist = indicators['macd_histogram']
            if macd_hist > 0:
                reasoning.append("MACD shows bullish momentum")
            elif macd_hist < 0:
                reasoning.append("MACD shows bearish momentum")
        
        # Asset-specific indicators
        if asset_class == AssetClass.CRYPTO:
            if 'realized_vol_24h' in indicators:
                reasoning.append(f"24h realized volatility: {indicators['realized_vol_24h']:.2%}")
            if 'momentum_24h' in indicators:
                mom = indicators['momentum_24h']
                reasoning.append(f"24h momentum: {mom:+.1%}")
        elif asset_class == AssetClass.FOREX:
            if 'trend_strength' in indicators:
                trend = indicators['trend_strength']
                if abs(trend) > 0.02:
                    direction = "upward" if trend > 0 else "downward"
                    reasoning.append(f"Strong {direction} trend detected")
        
        # Volatility
        if 'atr' in indicators:
            reasoning.append(f"Average True Range: ${indicators['atr']:.2f}")
        
        return reasoning
    
    def explain_prediction(
        self, 
        symbol: str, 
        data: pd.DataFrame,
        asset_class: AssetClass = AssetClass.STOCK
    ) -> Dict[str, Any]:
        """
        Provide detailed explanation of prediction for interpretability.
        
        Args:
            symbol: Stock symbol
            data: DataFrame with OHLCV data
            asset_class: Asset class
            
        Returns:
            Dictionary with detailed explanation including:
            - Model contributions
            - Feature importance
            - Technical indicator analysis
            - Confidence breakdown
        """
        # Generate signal
        signal = self.analyze_stock(symbol, data, asset_class)
        
        explanation = {
            'symbol': symbol,
            'asset_class': asset_class.value,
            'action': signal.action,
            'confidence': signal.confidence,
            'timestamp': signal.timestamp.isoformat(),
            'model_contributions': {},
            'technical_analysis': {},
            'feature_importance': {},
            'reasoning': []
        }
        
        # Model contributions
        for model, score in signal.reasoning['model_scores'].items():
            weight = self.ensemble_weights.get(model, 0.5)
            contribution = score * weight
            explanation['model_contributions'][model] = {
                'score': float(score),
                'weight': float(weight),
                'contribution': float(contribution)
            }
        
        # Technical analysis
        indicators = signal.reasoning['technical_indicators']
        explanation['technical_analysis'] = {
            'rsi': {
                'value': indicators.get('rsi'),
                'interpretation': self._interpret_rsi(indicators.get('rsi'))
            },
            'macd': {
                'value': indicators.get('macd_histogram'),
                'interpretation': self._interpret_macd(indicators.get('macd_histogram'))
            },
            'moving_averages': {
                'sma_20': indicators.get('sma_20'),
                'sma_50': indicators.get('sma_50'),
                'price_position': indicators.get('price_vs_sma20')
            },
            'volatility': {
                'atr': indicators.get('atr'),
                'bb_width': indicators.get('bb_width')
            }
        }
        
        # Add asset-specific indicators
        if asset_class == AssetClass.CRYPTO:
            explanation['technical_analysis']['crypto_specific'] = {
                'realized_vol_24h': indicators.get('realized_vol_24h'),
                'momentum_24h': indicators.get('momentum_24h'),
                'volume_ratio': indicators.get('volume_ratio')
            }
        elif asset_class == AssetClass.FOREX:
            explanation['technical_analysis']['forex_specific'] = {
                'trend_strength': indicators.get('trend_strength'),
                'atr_pct': indicators.get('atr_pct')
            }
        
        # Feature importance (from RF model if available)
        if self.rf_model is not None and self.rf_model.feature_importances_ is not None:
            importance_df = self.rf_model.get_feature_importance(top_n=10)
            explanation['feature_importance'] = importance_df.to_dict('records')
        
        # Generate reasoning
        recommendation = self.get_recommendation(symbol, data, asset_class)
        explanation['reasoning'] = recommendation.reasoning
        
        return explanation
    
    def _interpret_rsi(self, rsi_value: Optional[float]) -> str:
        """Interpret RSI value."""
        if rsi_value is None:
            return "N/A"
        if rsi_value > 70:
            return "Overbought"
        elif rsi_value < 30:
            return "Oversold"
        else:
            return "Neutral"
    
    def _interpret_macd(self, macd_hist: Optional[float]) -> str:
        """Interpret MACD histogram."""
        if macd_hist is None:
            return "N/A"
        if macd_hist > 0:
            return "Bullish"
        elif macd_hist < 0:
            return "Bearish"
        else:
            return "Neutral"
    
    def rank_opportunities(
        self,
        symbols: List[str],
        data_dict: Dict[str, pd.DataFrame],
        asset_classes: Optional[Dict[str, AssetClass]] = None,
        top_n: Optional[int] = None
    ) -> List[RankedStock]:
        """
        Rank multiple stocks by trading opportunity strength.
        
        Analyzes multiple stocks and ranks them by their trading opportunity
        score, considering confidence, expected return, and risk.
        
        Args:
            symbols: List of stock symbols to analyze
            data_dict: Dictionary mapping symbols to their OHLCV DataFrames
            asset_classes: Optional dictionary mapping symbols to asset classes
            top_n: Return only top N stocks (None for all)
            
        Returns:
            List of RankedStock objects sorted by score (highest first)
        """
        ranked_stocks = []
        
        for symbol in symbols:
            if symbol not in data_dict:
                logger.warning(f"No data available for {symbol}, skipping")
                continue
            
            try:
                # Determine asset class
                if asset_classes and symbol in asset_classes:
                    asset_class = asset_classes[symbol]
                else:
                    # Try to detect from symbol
                    from services.market_data_service import MarketDataService
                    mds = MarketDataService()
                    asset_class = mds.detect_asset_class(symbol)
                
                # Get recommendation
                recommendation = self.get_recommendation(symbol, data_dict[symbol], asset_class)
                
                # Calculate opportunity score (0-100)
                score = self._calculate_opportunity_score(recommendation)
                
                # Extract key factors
                key_factors = recommendation.reasoning[:3]  # Top 3 reasons
                
                # Create ranked stock
                ranked_stock = RankedStock(
                    symbol=symbol,
                    score=score,
                    action=recommendation.action,
                    confidence=recommendation.confidence,
                    expected_return=recommendation.expected_return,
                    risk_level=recommendation.risk_level,
                    key_factors=key_factors,
                    asset_class=asset_class
                )
                
                ranked_stocks.append(ranked_stock)
                
            except Exception as e:
                logger.error(f"Failed to analyze {symbol}: {e}")
                continue
        
        # Sort by score (descending)
        ranked_stocks.sort(key=lambda x: x.score, reverse=True)
        
        # Limit to top N if specified
        if top_n is not None:
            ranked_stocks = ranked_stocks[:top_n]
        
        logger.info(f"Ranked {len(ranked_stocks)} stocks")
        
        return ranked_stocks
    
    def _calculate_opportunity_score(self, recommendation: Recommendation) -> float:
        """
        Calculate opportunity score for ranking.
        
        Args:
            recommendation: Trading recommendation
            
        Returns:
            Score from 0 to 100
        """
        score = 0.0
        
        # Base score from confidence (0-40 points)
        score += recommendation.confidence * 40
        
        # Expected return contribution (0-30 points)
        if recommendation.expected_return is not None:
            # Cap at Â±20% return
            capped_return = max(-0.2, min(0.2, recommendation.expected_return))
            score += abs(capped_return) * 150  # 20% return = 30 points
        
        # Action bonus (0-20 points)
        if recommendation.action in ['buy', 'sell']:
            score += 20  # Strong signal
        else:
            score += 5  # Hold signal
        
        # Risk penalty (0-10 points deduction)
        risk_penalties = {'low': 0, 'medium': 5, 'high': 10}
        score -= risk_penalties.get(recommendation.risk_level, 5)
        
        # Ensure score is in valid range
        score = max(0, min(100, score))
        
        return float(score)
    
    def get_model_info(self) -> Dict[str, Any]:
        """
        Get information about loaded models.
        
        Returns:
            Dictionary with model information and status
        """
        info = {
            'models_loaded': self.models_loaded,
            'available_models': self.available_models,
            'ensemble_weights': self.ensemble_weights,
            'min_confidence_threshold': self.min_confidence_threshold,
            'model_details': {}
        }
        
        # LSTM info
        if self.lstm_model is not None:
            info['model_details']['lstm'] = {
                'type': 'LSTM Price Predictor',
                'sequence_length': self.lstm_model.sequence_length,
                'n_features': self.lstm_model.n_features,
                'lstm_units': self.lstm_model.lstm_units
            }
        
        # RF info
        if self.rf_model is not None:
            info['model_details']['rf'] = self.rf_model.get_model_info()
        
        return info


def create_default_engine(model_dir: str = 'data/models') -> AIEngine:
    """
    Create AI engine with default configuration.
    
    Args:
        model_dir: Directory containing trained models
        
    Returns:
        Configured AIEngine instance
    """
    engine = AIEngine(
        model_dir=model_dir,
        lstm_model_name='lstm_model',
        rf_model_name='rf_model',
        ensemble_weights={'lstm': 0.4, 'rf': 0.6}
    )
    
    return engine
